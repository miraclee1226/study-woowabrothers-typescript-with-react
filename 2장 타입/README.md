## 2.1 타입이란

### 정적 타입과 동적 타입

타입은 타입을 결정하는 시점에 따라 두 가지로 나뉜다.

- 정적 타입
    
    모든 변수의 타입이 컴파일 타임에 결정된다. 약간 번거롭지만 컴파일 타임에 에러를 발견할 수 있어서 프로그램 안정성을 보장할 수 있다.
    
    ex. C, 자바, 타입스크립트
    
- 동적 타입
    
    변수 타입이 런타임에서 결정된다. 따라서 개발 과정에서는 마음껏 코드를 작성 할 수 있지만 언제 프로그램 오류가 생길지 모르는 상태가 된다.
    
    ex. 파이썬, 자바스크립트
    

> **컴파일 타임**: 기계가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점
>
> **런타임**: 변환된 파일이 메모리에 적재되어 실행되는 시점
> 

### 강타입과 약타입

- 자바스크립트는 컴파일러나 엔진에 의해 런타임에 타입이 자동으로 변경되는데 이를 암묵적 타입 변환이라고 한다. 암묵적 타입 변환 여부에 따라 타입 시스템을 두 가지로 분류할 수 있다.
    - 강타입
        
        서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러가 발생한다.
        
        ex. 파이썬, 루비, 타입스크립트  
        
    - 약타입
        
        서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 값을 도출한다.
        
        ex. C++, 자바, 자바스크립트
        

> **점진적 타입이란?**
> 
> TS는 변수의 타입을 직접 정의하지 않아도 변수에 담기는 초기값을 기준으로 자동으로 알아서 타입을 추론한다. 이런 타입 시스템을 점진적으로 타입을 결정한다. 라고 해서 점진적 타입 시스템이라고 부른다.
>
> 
- 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙을 타입 시스템이라고 하며, 크게 두가지로 구분한다.
    - 어떤 타입을 사용하는지 컴파일러에게 명시적으로 알려줘야 하는 타입 시스템
    - 자동으로 타입을 추론하는 타입 시스템
    
    타입스크립트는 두 가지 타입 시스템에 모두 영향을 받았다. (뒤에서 구체적으로 나옴)
    

### 컴파일 방식

- 컴파일은 서로 다른 수준(고수준-저수준) 간의 코드 변환을 의미한다.
    
    보통 컴파일의 결과물은 0과 1로 이뤄진 바이너리 코드로 변환되는데 타입스크립트의 컴파일 결과물은 사람이 읽을 수 있는 자바스크립트 파일이다. 
    
    이처럼 타입스크립트는 다른 타입의 개념을 사용하는 언어와는 구별되는 특징을 가지고 있다. 따라서 자바스크립트에 타입이라는 레이어를 추가한 템플릿 언어 또는 확장 언어로 해석하는 의견도 있다.
    

## 2.2 타입스크립트의 타입 시스템

### 타입 애너테이션 방식

- 타입 애너테이션은 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것 인지를 컴파일러에게 직접 알려주는 문법이다.

### 구조적 타이핑

- 가장 기본적인 특성은 값을 할당할 때 정의된 타입에 필요한 속성을 가지고 있다면 호환된다는 점이다.
    
    아래의 코드를 보면 Cat은 Pet은 다른 타입으로 선언되었지만 Pet이 갖고 있는 name 속성이 있다. 따라서 Cat 타입으로 선언한 cat을 Pet 타입으로 선언한 pet에 할당할 수 있다.
    
    ```tsx
    interface Pet {
      name: string
    }
    
    interface Cat {
      name: string
      age: number
    }
    
    let pet: Pet;
    let cat: Cat = { name: "Zag", age: 2 };
    
    // ✅ OK
    pet = cat;
    ```
    

### 구조적 서브 타이핑

- 구조적 서브 타이핑은 상속 관계가 명시되어 있지 않더라도 객체의 프로퍼티를 기반으로 사용처에서 사용함에 문제가 없다면 타입 호환을 허용하는 방식이다.
    
    따라서 타입이 계층 구조로부터 자유롭다.
    
    ```jsx
    const burger = {
      protein: 29,
      carbohydrates: 48,
      fat: 13,
      burgerBrand: '버거킹'
    }
    
    const calorie = calculateCalorie(burger)
    /** 타입검사결과 : 오류없음 (OK) */
    ```
    

- 명목적 서브타이핑은 타입 정의 시에 상속 관계임을 명확히 명시한 경우에만 타입 호환을 허용한다.
    
    ```tsx
    /** 상속 관계 명시 */
    type Burger = Food & {
      burgerBrand: string;
    }
    
    const burger: Burger = {
      protein: 29,
      carbohydrates: 48,
      fat: 13,
      burgerBrand: '버거킹'
    }
    
    const calorie = calculateCalorie(burger)
    /** 타입검사결과 : 오류없음 (OK) */
    ```
    

### 자바스크립트를 닮은 타입스크립트

- 타입스크립트가 자바스크립트를 모델링 한 언어이기 때문에 구조적 타이핑을 채택했다.
- 자바스크립트는 덕 타이핑을 기반으로 한다.
- 덕 타이핑은 어떤 함수의 매개변숫값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다는 개념이다. 타입스크립트는 이런 동작을 그대로 모델링한다.
    - 덕 타이핑: 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식

> **덕타이핑과 구조적 타이핑**
>
> 둘의 차이는 타입을 검사하는 시점에 있다. 
> 전자는 런타임에 타입을 검사하지만 후자는 컴파일타임에 타입을 검사한다. 

따라서 자바스크립트는 덕 타이핑 언어이고 타입스크립트는 구조적 타이핑 언어이다.
> 

### 구조적 타이핑의 결과

구조적 타이핑 때문에 예기치 못한 결과가 나올 수 있는데 이를 위해 유니온 타입 같은 방법이 생겨났다.

### 타입스크립트의 점진적 타입 확인

타입스크립트는 점진적으로 타입을 확인하기 때문에 정적 타입의 정확성을 100% 정확성을 보장해주지 않는다.  모든 변수와 표현식의 타입을 컴파일 타임에 검사하지 않아도 되기 때문에 타입이 올바르게 정해지지 않으면 런타임에서 에러가 발생하기도 한다.

> noImplicitAny: 타입 애너테이션이 없을 때 변수가 any 타입으로 추론되는 것을 허락하지 않는다.
>
> 하지만 정확한 타이핑을 위해 이 옵션을 true로 설정하는게 좋다.

### 값 vs 타입

값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다. 

이것은 타입스크립트가 자바스크립트의 슈퍼셋인 것과 관련이 있다. type으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다.

- 클래스 문법
    
    타입스크립트에서 클래스는 타입 애너테이션으로 사용될 수 있지만 런타임에서 객체로 변환되어 자바스크립트의 값으로 사용되는 특징이 있다.
    
    ```tsx
    class Developer {
      name: string;
      domain: number;
    
      constructor(name: string, domain: number) {
        this.name = name;
        this.domain = domain;
      }
    }
    
    const developer: me = new Developer("zig", "frontend");
    ```
    
- enum
    
    마찬가지로 런타임에 객체로 변환된다.
    
    클래스 처럼 런타임에 실제 값으로도 사용될 수 있다.
    
    ```jsx
    enum Direction {
      Up, // 0
      Down, // 1
      Left, // 2
      Right, // 3
      }
    ```
    
    - 성능
        
        TypeScript에서 타입을 Enum으로 선언하게 되면 Babel로 컴파일 되면서 즉시실행함수(IIFE)로 변환된다. 따라서 실제로 쓰이지 않는 코드라도 번들러 입장에서 IIFE는 사용 여부를 판별할 수 없기 때문에 Tree Shaking이 되지 않는다.
        
        ```jsx
        // 일반 함수/변수 - Tree Shaking 가능
        export const RED = 0;
        export const GREEN = 1;
        export const BLUE = 2;
        
        // 만약 RED만 사용한다면
        import { RED } from './colors';
        console.log(RED); // GREEN, BLUE는 제거됨
        ```
        
        ```jsx
        // IIFE - Tree Shaking 불가능
        var Color;
        (function (Color) {
          Color[Color["Red"] = 0] = "Red";      // 이게 사용되는지 모름
          Color[Color["Green"] = 1] = "Green";  // 이것도 사용되는지 모름
          Color[Color["Blue"] = 2] = "Blue";    // 이것도 마찬가지
        })(Color || (Color = {}));
        
        // Color.Red만 사용해도 전체 IIFE가 포함됨
        console.log(Color.Red);
        ```
        
        번들러는 IIFE 내부에서 어떤 속성이 실제로 사용되는지 정적 분석으로 알 수 없기 때문에 안전하게 전체를 포함시킨다. (함수 실행 중에 동적으로 결정되는 부분이 있을 수 있기 때문)
        
        ```jsx
        // 번들러 입장에서 이 코드를 보면:
        (function (Color) {
          // 이 함수 내부에서 뭔가 복잡한 일이 일어남
          // 부수효과(side effect)가 있을 수 있음
          // 전역 변수를 수정할 수도 있음
          // 네트워크 요청을 할 수도 있음
        })(Color || (Color = {}));
        ```
        
        - 그렇다면 일반 함수는?
        일반 함수는 선언만 해두고 호출하지 않으면 Tree Shaking이 가능하지만 IIFE는 파일 로드 시 즉시 실행되기 때문에 번들러가 안전하게 제거할 수 없다.
            
            ```jsx
            // 호출되지 않으면 실행되지 않음
            function myFunction() {
              // 이 코드는 호출될 때만 실행됨
              // 사용되지 않으면 제거 가능
            }
            ```
            
    - 리버스 매핑
        
        번들 크기가 불필요하게 커지고 메모리도 2배로 사용하게 됨. 
        
        ```tsx
        enum Color {
          Red = 0,
          Green = 1,
          Blue = 2
        }
        
        // 컴파일 후 → { 0: "Red", 1: "Green", 2: "Blue", Red: 0, Green: 1, Blue: 2 }
        ```
        
    - 예상치 못한 에러
        
        문자열 enum은 역방향 매핑이 불가함. 숫자형 enum만 정방향, 역방향 모두 가능하다.
        
        ```jsx
        enum Direction {
          Up = 'UP',
          Down = 'DOWN',
          Left = 'LEFT',
          Right = 'RIGHT',
        }
        
        // Reverse mapping
        const directionName: string = Direction.Up; // 'UP'
        const directionValue: Direction = Direction['UP']; // Direction.Up -> Error!- 
        ```
        
- const enum
    
    실제로 사용하는 코드만 JavaScript 코드로 변환되기 때문에 Tree Shaking이 가능하다.
    
    하지만 Const Enum은 일반 상수로 치환되기 때문에 실제 런타임에 실행되는 코드에서 에러를 유발할 수 있다. 
    
    - 이를 방지하기 위하여 tsconfig compilerOptions에 isolatedModules 설정을 true로 설정하는 경우 const enum 또한 enum과 동일하게 즉시실행함수(IIFE)가 생성될 수 있기에 실행될때 100% 권장되지는 않는다고 한다.
    
    ```tsx
    const enum Color {
      Red = 0,
      Green = 1,
      Blue = 2
    }
    
    // 컴파일은 통과하지만 런타임 에러 발생
    console.log(Color); // ReferenceError: Color is not defined
    console.log(Object.keys(Color)); // ReferenceError: Color is not defined
    console.log(Object.values(Color)); // ReferenceError: Color is not defined
    ```
    

### 타입을 확인하는 방법

- typeof
    
    연산하기 전에 피연산자의 데이터 타입을 나타내는 문자열을 반환한다.
    
- instanceof
    
    프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있다.
    
- 타입 단언
    
    타입을 강제하는 방법이다. 형 변환을 강제할 수는 있지만 런타임에서는 효력을 발휘하지 못한다.
    
- 타입 가드
    
    특정 조건을 검사해서 타입을 정제하고 타입 안정성을 높이는 패턴이다. (뒤에서 자세히 다룬다)
    

## 2.3 원시타입

자바스크립트의 변수에는 어떤 타입의 값이라도 자유롭게 할당할 수 있다. 

1. boolean
2. undefined
3. null
4. number
5. bright
6. string
7. symbol
    1. 어떠한 값과도 중복되지 않는 유일한 값을 생성할 수 있다.

## 2.4 객체 타입

1. object
    
    객체에 해당하는 모든 타입을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문에 권장되지 않는 타입이다.
    
2. {}
    
    자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용된다. 타입스크립트에서도 객체를 타이핑 할 때 중괄호를 사용할 수 있다.
    
3. array
4. type과 interface 키워드
5. function
    
    타입스크립트에서도 함수를 별도 함수 타입으로 지정할 수 있다. 다만 앞서 살펴본 객체 타이핑과 달라 주의할 점이 있다.
    
    - typeof 연산자로 확인한 function 이라는 키워드 자체를 타입으로 사용하지는 않는다는 것이다.
    - 함수는 매개 변수 목록을 받을 수 있는데 타입스크립트에서는 매개변수도 별도 타입으로 지정해야 한다.
    
    > 함수 자체의 타입은 호출 시그니처를 이용하면 된다.
    >
    > 호출 시그니처는 타입스크립트에서 함수 타입을 정의할 때 사용하는 문법ㅂ으로 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.
    > 
    
    ```tsx
    type Operation2 = { (a: number, b: number): number };
    
    const add2: Operation2 = (a, b) => a + b;
    const sub2: Operation2 = (a, b) => a - b;
    const multiply2: Operation2 = (a, b) => a * b;
    const divide2: Operation2 = (a, b) => a / b;
    ```
